# Тестирование <br/>

Так как я реализовал три вида ввода, я разделил тестирование на три части. <br/>
`Я создал файл, включающий в себя всевозможные входные символы (так как работаем с ASCII 0-127) и постарался показать на примерах все видимые в консоли символы. 
`
### Первое - ввод вручную. 
Тут всё просто - несколько прогонов одинаковых вводных данных показали одинаковые результаты на исполняемом файле, скомпилированном напрямую из C-кода,и на том, который я собрал из модифицированного вручную ассемблера.
<br/>

![image](https://user-images.githubusercontent.com/44980361/201548385-b71fcb1a-fe18-4ad4-8ccf-a4f38e7b088b.png)
![image](https://user-images.githubusercontent.com/44980361/201548429-97e053f2-7183-4ab4-a74b-cb0a946340c9.png)
![image](https://user-images.githubusercontent.com/44980361/201548494-6fd2d90c-59e8-48c7-83c1-2559c2e1b183.png)


### Второе - ввод через аргументы командной строки
Аналогичная задача, только теперь много ограничений - нельзя использовать скобки, кавычки, пробелы, некоторые другие служебные символы - иначе терминал не поймёт, что мы имеем ввиду.
![image](https://user-images.githubusercontent.com/44980361/201548710-e2538695-77d0-4e07-a303-0df906137c3f.png)
![image](https://user-images.githubusercontent.com/44980361/201548766-303fa899-f626-4616-893d-fccb4585c0d2.png)
![image](https://user-images.githubusercontent.com/44980361/201548869-4f083ff1-b949-4f98-baf3-b232ce3b6bc3.png)
При длинных вводимых аргументах даже консоль визуально поплыла - но можно увидеть, что ответы по прежнему совпадают.


### Третье - файловый ввод
Ограничение на символы фактически пропало, поэтому я запустил программу со всеми возможными символами. Она отработала ровно до символа конца файла)) Но отработала одинаково
![image](https://user-images.githubusercontent.com/44980361/201549436-b3667679-46e9-4195-bb2b-9c5d8b29f9e6.png)
![image](https://user-images.githubusercontent.com/44980361/201549701-a11d85eb-c2dc-43c0-9bca-3978dbf803fd.png)

